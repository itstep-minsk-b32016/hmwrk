#include<iostream>
#include<time.h>
#include<stdlib.h>

int const SizeN1 = 355;	//Макимальный размер первого числа
int const SizeN2 = 355;	//Максимальный размер второго числа
int const SizeR = SizeN1 + SizeN2;	//Максимальный размер результата умножения
int const Col = SizeN1 + SizeN2;	//Максимальное количество столбцов промежуточного массива (Column)
int const Line = (SizeN1 > SizeN2) ? SizeN1 : SizeN2;	//Максимальное количество строк промежуточного массива

int main()
{
	int N1[SizeN1], N2[SizeN2];	//Массивы для первого и второго чисел
	int Cap_N1, Cap_N2;	//Capacity - вместимость, ёмкость, число разрядов...
	setlocale(LC_ALL, "Russian");
	std::cin >> Cap_N1;
	for (int i = Cap_N1 - 1; i >= 0; i--)	//Заполняем первый массив числом, сразу же его переворачивая задом наперед для удобства работы
	{
		std::cin >> N1[i];
	}
	std::cin >> Cap_N2;
	for (int i = Cap_N2 - 1; i >= 0; i--)	//Аналогично заполняем второй массив
	{
		std::cin >> N2[i];
	}

	int MasVar[Line][Col];	//Промежуточный массив для результатов перемножения разрядов чисел
	for (int i = 0; i < Line; i++)	//Заполняем промежуточный массив нулями чтобы не было случайных ошибок из-за "мусора" в ячейках
	{
		for (int j = 0; j < Col; j++)
		{
			MasVar[i][j] = 0;
		}
	}

	for (int i = 0; i < Cap_N1; i++)	//Каждый разряд первого числа будем умножать на все разряды второго числа
	{
		int memory = 0;	//Переменная для "три пишем - два в уме" если результат умножения будет иметь два разряда
		int j = i;

		for (j; j < i + Cap_N2; j++)	//При умножении очередного разряда первого числа на второе, результаты будут заноситься в промежуточный массив 
		{								//со сдвигом на одну ячейку как при умножении в столбик "на бумаге"
			MasVar[i][j] = N1[i] * N2[j - i] + memory;	//Умножаем разряд первого числа на разряд второго и плюсуем то, что "в уме"
			memory = 0;	//Обнуляем значение "в уме"
			if (MasVar[i][j]>9)	//Если результат умножения имеет два разряда
			{
				memory = MasVar[i][j] / 10;	//Десятки (результат целочисленного деления) "держим в уме"
				MasVar[i][j] %= 10;			//Единицы (остаток от деления) заносим в ячейку
			}
		}
		MasVar[i][j] = memory;	//Если результат умножения на последний разряд второго числа больше 9-ти, мы не потеряем десятки.
	}							//Иначе сюда заносится ноль который в дальнейшем никак не мешает и не влияет на результат вычислений

	int memory = 0;		//Переменная "в уме" для сложения
	int MasRes[SizeR];	//Массив для конечного результата
	int Real_Col = Cap_N1 + Cap_N2;	//Реально используемое количество столбцов промежуточного массива, чтобы не проходить по всему промежуточному массиву и не складывать "пустые" значения
	int Real_Line = Cap_N1 > Cap_N2 ? Cap_N1 : Cap_N2;	//Реально используемое количество строк промежуточного массива равно количеству разрядов бОльшего из двух чисел

	for (int j = 0; j < Real_Col; j++)	//Проходим по "значащим" столбцам от начала до конца
	{
		int temp_sum = 0;	//Переменная для суммы значений содержащихся в ячейках столбца. Здесь же она обнуляется при переходе к следующему столбцу
		for (int i = 0; i < Real_Line; i++)	//Проходим по "значащим" строкам от начала до конца (т.е. по каждой ячейке в текущем столбце)
		{
			temp_sum += MasVar[i][j] + memory;	//Суммируем все значения и прибавляем то. что "в уме"
			memory = 0;	//Очищаем "в уме"
		}
		if (temp_sum>9)	//Если сумма имеет больше одного разряда
		{
			MasRes[j] = temp_sum % 10;	//В ячейку заносим единицы (остаток от деления)
			memory = temp_sum / 10;	//Всё, что больше единиц держим "в уме" (результат целочисленного деления)
		}
		else
		{
			MasRes[j] = temp_sum;	//Если сумма имеет только один разряд сразу записываем её в ячейку
		}
	}
	std::cout << "Результат: ";
	for (int i = Real_Col - 1; i >= 0; i--)	//Выводим все полченные значения с последней ячейки результирующего массива до первой
	{										//чтобы получилось число в правильном виде, а не перевернутом
		std::cout << MasRes[i];
	}
	std::cout << std::endl;
	return 0;
}
